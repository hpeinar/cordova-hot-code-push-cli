import path from 'path';
import prompt from 'prompt';
import fs from 'fs-extra';
import crypto from 'crypto';
import _ from 'lodash';
import { getAllFilesSync } from 'get-all-files';
import hidefile from 'hidefile';
import glob from 'fast-glob';

const createHash = crypto.createHash;

let chcpContext = null;

export async function execute(context) {
    chcpContext = context;

    let config = prepareConfig(context);
    let ignore = context.ignoredFiles;

    //let files = await getAllFilesSync(chcpContext.sourceDirectory).toArray();

    console.log('ignore', ignore);
    let source = chcpContext.sourceDirectory
        .split(path.sep)
        .join(path.posix.sep);
    console.log('Source', source);
    let files = await glob(`${source}/**/**`, {
        onlyFiles: true,
        ignore: ignore,
    });

    // Now remove the ignored files

    console.log('After', files);

    let hashQueue = prepareFilesHashQueue(files);

    const manifestFile = chcpContext.manifestFilePath;
    try {
        fs.writeFileSync(manifestFile, JSON.stringify(hashQueue));
        console.log('Hashqueue', hashQueue);
    } catch (err) {
        return console.log(err);
    }

    if (context.argv && context.argv.localdev) {
        config.update = 'now';
    }
    try {
        fs.writeFileSync(
            chcpContext.projectsConfigFilePath,
            JSON.stringify(config, null, 2)
        );
        console.log('Written to ' + chcpContext.projectsConfigFilePath);
        console.log(
            'Build ' +
                config.release +
                ' created in ' +
                chcpContext.sourceDirectory
        );
    } catch (err) {
        console.log(err);
        throw err;
    }
    return config;
}

function prepareFilesHashQueue(files) {
    var queue = [];
    for (var i in files) {
        var file = files[i];
        if (!hidefile.isHiddenSync(file)) {
            queue.push(fileHashSync(file));
        }
    }

    return queue;
}

function prepareConfig(context) {
    var config = {};

    try {
        config = fs.readFileSync(context.defaultConfig, 'utf8');
        config = JSON.parse(config);
        config.release = process.env.VERSION || calculateTimestamp();
    } catch (e) {
        config = {
            autogenerated: true,
            release: calculateTimestamp(),
        };
    }

    if (context.argv && context.argv.content_url) {
        config.content_url = context.argv.content_url;
    }

    return config;
}

function fileHashSync(filePath) {
    var fileData;

    try {
        fileData = fs.readFileSync(filePath, 'utf8');
    } catch (err) {
        if (err.code === 'ENOENT')
            return console.error('File does not exist. Error: ', err);

        return console.error('Error: ', err);
    }

    //console.log('srouce', chcpContext.sourceDirectory);
    let file = path
        .relative(chcpContext.sourceDirectory, filePath)
        .replace(new RegExp('\\\\', 'g'), '/');

    return {
        file: file,
        hash: crypto.createHash('md5').update(fileData, 'utf8').digest('hex'),
    };
}

function hashFile(filename, callback) {
    var hash = crypto.createHash('md5');
    const stream = fs.createReadStream(filename);

    //stream.pipe(writeStream);
    //console.log('Hashing: ', filename);
    stream.on('data', function (data) {
        hash.update(data, 'utf8');
    });

    stream.on('end', function () {
        var result = hash.digest('hex'),
            file = path
                .relative(chcpContext.sourceDirectory, filename)
                .replace(new RegExp('\\\\', 'g'), '/');

        callback(null, {
            file: file,
            hash: result,
        });
    });
}

function calculateTimestamp() {
    var currentdate = new Date();
    return (
        currentdate.getFullYear() +
        '.' +
        (currentdate.getMonth() + 1 < 10
            ? '0' + (currentdate.getMonth() + 1)
            : currentdate.getMonth() + 1) +
        '.' +
        (currentdate.getDate() < 10
            ? '0' + currentdate.getDate()
            : currentdate.getDate()) +
        '-' +
        (currentdate.getHours() < 10
            ? '0' + currentdate.getHours()
            : currentdate.getHours()) +
        '.' +
        (currentdate.getMinutes() < 10
            ? '0' + currentdate.getMinutes()
            : currentdate.getMinutes()) +
        '.' +
        (currentdate.getSeconds() < 10
            ? '0' + currentdate.getSeconds()
            : currentdate.getSeconds())
    );
}
