"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.execute = execute;

require("core-js/modules/es.promise.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.string.split.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.regexp.constructor.js");

require("core-js/modules/es.regexp.to-string.js");

var _path = _interopRequireDefault(require("path"));

var _prompt = _interopRequireDefault(require("prompt"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _crypto = _interopRequireDefault(require("crypto"));

var _lodash = _interopRequireDefault(require("lodash"));

var _getAllFiles = require("get-all-files");

var _hidefile = _interopRequireDefault(require("hidefile"));

var _fastGlob = _interopRequireDefault(require("fast-glob"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const createHash = _crypto.default.createHash;
let chcpContext = null;

async function execute(context) {
  chcpContext = context;
  let config = prepareConfig(context);
  let ignore = context.ignoredFiles; //let files = await getAllFilesSync(chcpContext.sourceDirectory).toArray();

  console.log('ignore', ignore);
  let source = chcpContext.sourceDirectory.split(_path.default.sep).join(_path.default.posix.sep);
  console.log('Source', source);
  let files = await (0, _fastGlob.default)("".concat(source, "/**/**"), {
    onlyFiles: true,
    ignore: ignore
  }); // Now remove the ignored files

  console.log('After', files);
  let hashQueue = prepareFilesHashQueue(files);
  const manifestFile = chcpContext.manifestFilePath;

  try {
    _fsExtra.default.writeFileSync(manifestFile, JSON.stringify(hashQueue));

    console.log('Hashqueue', hashQueue);
  } catch (err) {
    return console.log(err);
  }

  if (context.argv && context.argv.localdev) {
    config.update = 'now';
  }

  try {
    _fsExtra.default.writeFileSync(chcpContext.projectsConfigFilePath, JSON.stringify(config, null, 2));

    console.log('Written to ' + chcpContext.projectsConfigFilePath);
    console.log('Build ' + config.release + ' created in ' + chcpContext.sourceDirectory);
  } catch (err) {
    console.log(err);
    throw err;
  }

  return config;
}

function prepareFilesHashQueue(files) {
  var queue = [];

  for (var i in files) {
    var file = files[i];

    if (!_hidefile.default.isHiddenSync(file)) {
      queue.push(fileHashSync(file));
    }
  }

  return queue;
}

function prepareConfig(context) {
  var config = {};

  try {
    config = _fsExtra.default.readFileSync(context.defaultConfig, 'utf8');
    config = JSON.parse(config);
    config.release = process.env.VERSION || calculateTimestamp();
  } catch (e) {
    config = {
      autogenerated: true,
      release: calculateTimestamp()
    };
  }

  if (context.argv && context.argv.content_url) {
    config.content_url = context.argv.content_url;
  }

  return config;
}

function fileHashSync(filePath) {
  var fileData;

  try {
    fileData = _fsExtra.default.readFileSync(filePath, 'utf8');
  } catch (err) {
    if (err.code === 'ENOENT') return console.error('File does not exist. Error: ', err);
    return console.error('Error: ', err);
  } //console.log('srouce', chcpContext.sourceDirectory);


  let file = _path.default.relative(chcpContext.sourceDirectory, filePath).replace(new RegExp('\\\\', 'g'), '/');

  return {
    file: file,
    hash: _crypto.default.createHash('md5').update(fileData, 'utf8').digest('hex')
  };
}

function hashFile(filename, callback) {
  var hash = _crypto.default.createHash('md5');

  const stream = _fsExtra.default.createReadStream(filename); //stream.pipe(writeStream);
  //console.log('Hashing: ', filename);


  stream.on('data', function (data) {
    hash.update(data, 'utf8');
  });
  stream.on('end', function () {
    var result = hash.digest('hex'),
        file = _path.default.relative(chcpContext.sourceDirectory, filename).replace(new RegExp('\\\\', 'g'), '/');

    callback(null, {
      file: file,
      hash: result
    });
  });
}

function calculateTimestamp() {
  var currentdate = new Date();
  return currentdate.getFullYear() + '.' + (currentdate.getMonth() + 1 < 10 ? '0' + (currentdate.getMonth() + 1) : currentdate.getMonth() + 1) + '.' + (currentdate.getDate() < 10 ? '0' + currentdate.getDate() : currentdate.getDate()) + '-' + (currentdate.getHours() < 10 ? '0' + currentdate.getHours() : currentdate.getHours()) + '.' + (currentdate.getMinutes() < 10 ? '0' + currentdate.getMinutes() : currentdate.getMinutes()) + '.' + (currentdate.getSeconds() < 10 ? '0' + currentdate.getSeconds() : currentdate.getSeconds());
}
//# sourceMappingURL=build.js.map